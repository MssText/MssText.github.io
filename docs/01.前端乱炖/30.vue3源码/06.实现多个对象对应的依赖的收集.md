---
title: 实现多个对象对应的依赖的收集
date: 2021-10-16 17:23:39
permalink: /pages/cb7a21/
categories:
  - 前端乱炖
  - vue3源码
tags:
  - 
---
上篇文章[实现对象多个属性对应的依赖的收集](https://masongsong.cn/pages/cb7a21/)我们实现了将 `属性` 和 `依赖` 的关系维护了起来，并且读取该属性的时候只会收集该属性所对应的依赖，设置该属性的时候只会触发该属性所对应的依赖。同时，我们也发现了一个问题，我们需要将`响应式对象`和`该对象的属性对应的所有的依赖`关系维护起来。那么如何做呢？我们来看。

首先我们可以明确一点，这肯定也是一个`map`结构，因为很明确的`key`和`value`的关系。只不过此时我们的`key`是一个对象，`value`是一个`map`。什么样的数据结构符合这样的对应关系呢？你别说，还真有，这就是[WeakMap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)，使用`WeakMap`不只是因为它很适合这种场景，还有别的优点：
- WeakMap 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。
- 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。
也就是说，对于`WeakMap`保存的对象的引用，垃圾回收器会监听这个对象是否是在使用，如果没有，就会自动回收这个对象。避免内存溢出和不必要的空间占用。这对于Vue3提高性能也是很有帮助的。可能还有同学不太明白，我们可以画个简单的图方便大家理解：
  
  ::: center
  <img src="https://cdn.jsdelivr.net/gh/MssText/learn@master/images/depsFull.png">
  :::
  
  我们最后就是使用这样的明确了思路，接下来我们用代码实现下：
  
首先我们需要在`track`函数里面将`depsMap`收集进我们定义的`WeakMap`容器：
  ```js
  // 使用 WeakMap 描述多个对象的多个属性对应多个依赖的对应关系
  const targrtMap = new WeakMap()

// 收集依赖函数
function track(target, key) {
  let depsMap = targrtMap.get(target)

  if (!depsMap) {
    targrtMap.set(target, depsMap = new Map())
  }

  let dep = depsMap.get(key)
  if (!dep) {
    depsMap.set(key, dep = new Set())
  }
  // 收集依赖
  dep.add(effect)
}
```
同时，`reactive`函数中调用的时候，就需要传入当前需要进行响应式包装的对象:
```js
function reactive(target) {
  // ...
  const handles = {
    get: function(target, key, receiver) {
      // ...
    }
    // 新增 传入响应式对象 target
      track(target, key)
    },
    // ...
}
```
这样我们就将对象和依赖收集容器的关系维护好了，同样的我们去将`trigger`函数也进行改进：
```js
function trigger(target, key) {
  // 新增 先根据对象取出所有属性对应的依赖容器
  let depsMap = targrtMap.get(target)
  let dep = depsMap.get(key)
  if (dep) {
    dep.forEach(effect => effect())
  }
}
```
`trigger`函数执行的时候，也需要传入该响应式对象：
```js
function reactive(target) {
  const handles = {
    // ...
    set: function(target, key, value) {
      // 新增 传入 target
      trigger(target, key)
    }
  }
  // ...
}
```
好了，这样我们就解决`对象`对应`依赖收集容器`的对应关系。但这就完美了吗？相信有的同学很早就发现了一个问题，依赖收集和执行的依赖关系倒是维护好了，但是收集的依赖我们并没有做区分啊，按照我们当前的实现，我们是直接使用`effect`定义依赖函数：
```js
let effect1 = () => {
  // ...
}

let effect2 = () => {
  // ...
}
```
但是我们收集的时候，是暴力收集，没有做任何区分：
```js
function track(target, key) {
  let depsMap = targrtMap.get(target)

  if (!depsMap) {
    targrtMap.set(target, depsMap = new Map())
  }

  let dep = depsMap.get(key)
  if (!dep) {
    depsMap.set(key, dep = new Set())
  }
  // 收集依赖
  dep.add(effect)
}
```
我们只能收集一个`effect`函数，那我们就得思考一下了，这里肯定不能直接收集`effect`,那我们需要改造下`effect`函数了，我们需要使用一个全局变量`activeEffect`标识当前正在收集的依赖，然后需要改造下`effect`函数，如下：
```js
// 使用 activeEffect 变量保存当前激活的 effect
let activeEffect = null

// 副作用函数
function effect(eff) {
  activeEffect = eff
  activeEffect()
  activeEffect = null
}
```
可以看到，我们改造了`effect`函数，我们此时并不是使用`effect`去定义依赖函数，而是采用高级函数的思想，将依赖函数作为参数`eff`传入`effect`,
并且使用全局变量`activeEffect`保存起来，这里为啥使用`activeEffect`这个全局变量呢？我们分析下:
```js
function a () {
  // ...
}

function b () {
  // ...
}

```
可以看到我们定义了两个函数`a`，`b`,那我们我们如何在`a`函数和`b`函数中共享变量呢？它们属于不同的作用域，却要共享变量，那只能在他们的父级作用域定义该变量了：
```js
let count = 0
function a () {
  // 这里能拿到
  console.log(count)
}

function b () {
  // 这里也能拿到
  console.log(count)
}

```
现在想必大家明白`activeEffect`的作用了吧，实际就是方便在`track`和`trigger`之间共享依赖函数。再回到`effect`函数的实现：
```js
function effect(eff) {
  activeEffect = eff
  activeEffect()
  activeEffect = null
}
```
我们使用`activeEffect`保存了依赖函数后，立即调用了一次，为什么会立即调用一次呢？这需要说到我们的实际应用场景：使用过vue的同学都知道，我们定义了响应式的数据，页面就会默认渲染我们的数据驱动的视图。未完待续......
